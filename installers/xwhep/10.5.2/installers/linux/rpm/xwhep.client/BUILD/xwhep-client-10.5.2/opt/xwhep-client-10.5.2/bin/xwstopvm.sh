#!/bin/sh
#=============================================================================
#
#  File    : xwstartvm.sh
#  Date    : November, 2011
#  Author  : Oleg Lodygensky
#
#  Change log:
#  - august 6th,2013 : Etienne Urbah
#  - July 18th, 2013 : Oleg Lodygensky
#  - jan 13th, 2014  : Oleg Lodygensky
#    - ide controller replaced by sata
#    - VM used to have only one disk, the "scratch" disk
#      this scratch disk is replaced by 3 different disks
#      VM now has up to three disks : application disk (optional), input disk (optional) and result disk
#      if result disk is not provided, a default 10Gb one is created
#  - sept 30th, 2014  : Oleg Lodygensky
#    - Correcting volume mountage incoherency.
#      All VM now have 4 disks: context, app, input and results.
#      Because, if one is missing, disks may be mounted in incoherent mount point.
#      (e.g. if no app disk is provided, input disk may be mounted on /mnt/app instead of /mnt/input) 
#      To be more readable, disk ports are now fixed:
#      * context     disk is attached to disk port 1
#      * application disk is attached to disk port 2
#      * input       disk is attached to disk port 3
#      * result      disk is attached to disk port 4
# - Oct 24th, 2014 : Oleg Lodygensky
#   Get kernel console for debugging boot process, if needed
#     sl6[2|4]_createlivecd.ks bootloader options : bootloader --location=mbr --driveorder=sda --append="selinux=0 console=ttyS0 console=tty0 ignore_loglevel"
#     See SERIALOUT
#     Ref : https://www.virtualbox.org/wiki/Serial_redirect
#  - dec 5th, 2014  : modified by Oleg Lodygensky
#    - enabling VirtualBox shared file systems
#    - the worker can not create ISO files since this requires administrator privileges
#      hence createsiso script is not used any more
#
#  OS      : Linux, mac os x
# 
#  Purpose : this script creates and starts a new VirtualBox VM on worker side
#
# Two env variables must be set when calling this script : 
# (they are automatically set by the worker)
#  - XWSCRATCHPATH : this must contains the directory where drive are stored
#
# 
#  !!!!!!!!!!!!!!!!    DO NOT EDIT    !!!!!!!!!!!!!!!!
#  Remarks : this script is auto generated by install process
#
#=============================================================================


# Copyrights     : CNRS
# Author         : Oleg Lodygensky
# Acknowledgment : XtremWeb-HEP is based on XtremWeb 1.8.0 by inria : http://www.xtremweb.net/
# Web            : http://www.xtremweb-hep.org
# 
#      This file is part of XtremWeb-HEP.
#
#    XtremWeb-HEP is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    XtremWeb-HEP is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with XtremWeb-HEP.  If not, see <http://www.gnu.org/licenses/>.
#
#


#  ******************************************************************
#   WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN 
#
#    HDA1 file is deleted by clean() method
#
#   WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN 
#  ******************************************************************


#=============================================================================
#
#  Global variables
#
#qemu-system-x86_64 -m 2048 -cdrom xwhd2016-01-05-14-06-29-livecd-sl64.iso -net user,hostfwd=tcp::10022-:22 -net nic
#=============================================================================
SCRIPTNAME="$0"
if [ "${SCRIPTNAME#*.sh}" ]; then
  SCRIPTNAME=xwstartvm.sh
  VERBOSE=TRUE
  TESTINGONLY=''                         # Worker, so debug is NOT possible
else
  VERBOSE=''
  TESTINGONLY=TRUE                       # Local machine, so debug is possible
fi

ROOTDIR="$(dirname "$0")"


VBROOT=/Applications/VirtualBox.app/Contents/MacOS/
VBMGT="$VBROOT/VBoxManage"
VBHL="$VBROOT/VBoxHeadLess"
#VBHL="$VBROOT/VirtualBox"

LOCKNAME=xwvm.lock
LOCKDIR=/tmp/
LOCKPATH="$LOCKDIR/$LOCKNAME"

# machines dir
VBMDIR="/tmp"
VBMDIR1="/tmp"
VBMDIR2="/tmp"
# disks disk
VBHDIR="/tmp"

VMOSTYPE=Linux26_64

#
# This is the RAM size
# Default : 512Mb
# May be overidden by XWRAMSIZE env var
#
VMRAM=512

VMCPUS=1
VMSTORAGECTRLNAME=sata_ctrl
VMSTORAGECTRLTYPE=sata

#
# These are the commands to execute
# this is set by --install command line parameter
INSTALL="TRUE"
# this is set by --uninstall command line parameter
UNINSTALL="TRUE"
# this is set by --start command line parameter
START="TRUE"
# this is set by --stop command line parameter
STOP="TRUE"

VWORKERDISKTRAILERNAME="vworker"
RESULTDISKTRAILERNAME="result"

#
# This is the working disk size
# Default : 30Mb
# May be overidden by XWDISKSPACE env var
#
SCRATCHSIZE=30

WAITDELAY=2

HDTYPE="hdd"
DVDTYPE="dvddrive"
HDTYPECLOSE="disk"
DVDTYPECLOSE="dvd"


HDADEVICE=0
HDA1PORT=0

SHAREDFS=""
SHAREDFSNAME="xwsharedfs"


#####################################################################
# Since Jul 7th, 2014, VDI creation has been moved to an external
# script to avoid code duplication
#   * createdvdi
#
# For the worker: RPM, DEB and Apple packages
#   * install :  $XWHOME_DIR/bin/createvdi 
#   * create  :  two sym links : /usr/bin/xwcreatevdi
# For the worker: linux packages
#   * add the following line to /etc/sudoers
#       "xwhep ALL=NOPASSWD: /usr/bin/xwcreatevdi"
#####################################################################
CREATEVDISCRIPTNAME=createvdi
XWCREATEVDISCRIPTNAME=xwcreatevdi
# next is the path when installed from installation package
CREATEVDI="/usr/bin/$XWCREATEVDISCRIPTNAME"
# next is the path when using the source package
[ ! -x $CREATEVDI ] && CREATEVDI="/usr/local/bin/$CREATEVDISCRIPTNAME"
[ ! -x $CREATEVDI ] && CREATEVDI="$ROOTDIR/$CREATEVDISCRIPTNAME"
if [ ! -x $CREATEVDI ] ; then
  echo  "`date`  $SCRIPTNAME  FATAL : can't find $XWCREATEVDISCRIPTNAME"
  exit 1
fi

#####################################################################
#
#  The following variable is set by xwaddvbapp.sh script
#  It may also be set by --hda command line parameter
#
#  This is the main bootable virtual drive
#  This must be set
#  This may be an ISO, VDI, VHD or VMDK file
#
#  ******************************************************************
#   WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN 
#
#    This file is deleted by clean() method
#
#   WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN 
#  ******************************************************************
HDA1FILE=""
#####################################################################


#HDBDEVICE=1
# 13 janvier 2014: using sata and not ide
# HDBDEVICE must be 0 since we use one SATA hardware only
HDBDEVICE=0
CONTEXT_DISKPORT=1
APP_DISKPORT=2
INPUT_DISKPORT=3
RESULT_DISKPORT=4

HDB1FILE_CONTEXT=""
HDB2FILE_APP=""
HDB3FILE_INPUT=""
HDB4FILE_OUTPUT=""


#
# XWPORTS is the env var that may contain a comma separated ports list
#
# NAT ssh port forwarding localhost:$XWPORTS[0] to guest:22
#
SSHLOCALPORT=
SSHGUESTPORT=22
#
# NAT http port forwarding localhost:$XWPORTS[1] to guest:80
#
HTTPLOCALPORT=
HTTPGUESTPORT=80

THISOS=`uname -s`

case "$THISOS" in
  
  Darwin )
    DATE_FORMAT='+%Y-%m-%d %H:%M:%S%z'
    VBROOT=/Applications/VirtualBox.app/Contents/MacOS/
    VBMGT="$VBROOT/VBoxManage"
    VBHL="$VBROOT/VBoxHeadLess"
    VBMDIR="$HOME/Library/VirtualBox/Machines"
    VBMDIR1="$HOME/Library/VirtualBox/"
    VBMDIR2="$HOME/VirtualBox VMs"
    VBHDIR="$HOME/Library/VirtualBox/HardDisks"
    ;;
  
  Linux )
    DATE_FORMAT='--rfc-3339=seconds'
    VBROOT=/usr/bin
    VBMGT="$VBROOT/vboxmanage"
    VBHL="$VBROOT/vboxheadless"
    VBMDIR="$HOME/Library/VirtualBox/Machines"
    VBMDIR1="$HOME/Library/VirtualBox/Machines"
    VBMDIR2="$HOME/VirtualBox VMs"
    VBHDIR="$HOME/Library/VirtualBox/HardDisks"
	CREATEVDI="sudo /usr/bin/$XWCREATEVDISCRIPTNAME"
    ;;
  
  * )
    fatal  "OS not supported ($THISOS)"  TRUE
    ;;
  
esac


VBREQUIREDVERSION="5.1"

VBVERSION="$("$VBMGT"  -v  |  cut  -d .  -f 1-2)"


#=============================================================================
#
#  Function  usage ()
#
#=============================================================================
usage()
{
  echo "Usage : $0 : this remove VM from VirtualBox"
  exit 0
}


#=============================================================================
#  Function  debug_message (Message part, ...)
#=============================================================================
debug_message ()
{
  [ "$VERBOSE" ]  ||  return
  echo  "$(date "$DATE_FORMAT")  $SCRIPTNAME  DEBUG: " "$@"  > /dev/stderr
}


#=============================================================================
#  Function  info_message (Message part, ...)
#=============================================================================
info_message ()
{
  echo  "$(date "$DATE_FORMAT")  $SCRIPTNAME  INFO: " "$@"
}


#=============================================================================
#  Function  warning_message (Message part, ...)
#=============================================================================
warning_message ()
{
  echo  "$(date "$DATE_FORMAT")  $SCRIPTNAME  WARNING: " "$@"
}


#=============================================================================
#  Function  wait_for_other_virtualbox_management_to_finish (function_name)
#=============================================================================
wait_for_other_virtualbox_management_to_finish ()
{
  debug_message  "$1 '$VMNAME' :  Wait for other VirtualBox management to finish"
  debug_message  "$1 '$VMNAME' :  ps  -e  -o user,pid,args  |  grep ${VBMGT##*/}"
  while  ps  -e  -o user,pid,args  |  grep -v grep  |  \
                                      grep "${VBMGT##*/}"  > /dev/stderr; do
  debug_message  "$1 '$VMNAME' :  Sleep 10"
	
    ( [ "$VERBOSE" ]  &&  set -x
      sleep 10 )
  done
}


#=============================================================================
#  Function  stop ()
#=============================================================================
stop ()
{
  echo
  info_message  "stop '$VMNAME'"
  
  [ "$VERBOSE" ]  &&  echo  > /dev/stderr
  wait_for_other_virtualbox_management_to_finish  stop

  info_message  "stop:  restarting to be sure we can stop (regardless the machine state)"
  ( [ "$VERBOSE" ]  &&  set -x
    "$VBHL"  --startvm  "$VMNAME" )  &
  sleep 5
  info_message  "stop:  Stopping"
    ( [ "$VERBOSE" ]  &&  set -x
      "$VBMGT"  controlvm  "$VMNAME"  poweroff )
}


#=============================================================================
#
#  Function  calculate_disk_type_in_function_of_suffix (DISK_FILENAME)
#
#  Variables set:  DISK_TYPE
#                  DISK_TYPE_CLOSE
#
#=============================================================================
calculate_disk_type_in_function_of_suffix ()
{
  DISK_EXT="${1##*.}"
  
  if [ "$DISK_EXT" = "iso" ]; then
      DISK_TYPE="$DVDTYPE"
      DISK_TYPE_CLOSE="$DVDTYPECLOSE"
      
  elif [ '(' "$DISK_EXT" = "vdi"  ')'  -o  \
         '(' "$DISK_EXT" = "vmdk" ')'  -o  \
         '(' "$DISK_EXT" = "vhd"  ')' ]; then
      DISK_TYPE="$HDTYPE"
      DISK_TYPE_CLOSE="$HDTYPECLOSE"
      
  else
      DISK_TYPE=""
      DISK_TYPE_CLOSE=""
      
  fi
}

#=============================================================================
#
#  Function  disk_dettach ()
# This dettaches a disk and deletes it, if not virtualized worker
# @param $1 : port number
# @param $2 : device number
#
#=============================================================================
disk_dettach () 
{
	PORT=$1
	DEVICE=$2

	DISKFILE="$(grep ${VMSTORAGECTRLNAME}-${PORT}-${DEVICE} "$INFOFILE"  |  cut  -d \"  -f 4)"
	DISKUUID="$(grep ${VMSTORAGECTRLNAME}-ImageUUID-${PORT}-${DEVICE} "$INFOFILE"  |  cut  -d \"  -f 4)"


	if [ "X$DISKFILE" = "X" ] ; then
		info_message  "disk_dettach : can't find disk file ($1 $2 $3)"
		return
	fi

	info_message  "disk_dettach $VMNAME : $DISKFILE $DISKUUID"

	calculate_disk_type_in_function_of_suffix  "$DISKFILE"

  [ "$VERBOSE" ]  &&  cat  << END_OF_DISKDETTACH_VARS  > /dev/stderr
	VMNAME="$VMNAME"
	PORT=$PORT
	DEVICE=$DEVICE
	DISK_TYPE=$DISK_TYPE
	DISK_TYPE_CLOSE=$DISK_TYPE_CLOSE
	DISKFILE=$DISKFILE
	DISKUUID=$DISKUUID
END_OF_DISKDETTACH_VARS

#
# dettach drive
#
	wait_for_other_virtualbox_management_to_finish  disk_dettach
	( [ "$VERBOSE" ]  &&  set -x
		"$VBMGT"  storageattach  "$VMNAME"  \
		--storagectl "$VMSTORAGECTRLNAME" \
		--port       "$PORT"  \
		--device     "$DEVICE" \
		--type       "$DISK_TYPE"  \
		--medium     none )
	
	[ $? -ne 0 ] && return

	EFFACE='--delete'
#
# keep result disk
#
	{ echo "$DISKFILE"  |  grep "${RESULTDISKTRAILERNAME}"  > /dev/null 2>&1 ; }  &&  \
		EFFACE=""
#
# if it is a virtualized worker (vworker), delete
#
	{ echo "$DISKFILE"  |  grep "${VWORKERDISKTRAILERNAME}"  > /dev/null 2>&1 ; }  &&  \
		EFFACE="--delete"

    [ "$TESTINGONLY" = "TRUE" ] && EFFACE=""

    wait_for_other_virtualbox_management_to_finish  disk_dettach
	debug_message  "dettach disk '$VMNAME' : closemedium  $DISK_TYPE_CLOSE'  '$DISKFILE'  $EFFACE"
	( [ "$VERBOSE" ]  &&  set -x
	 "$VBMGT"  closemedium  "$DISK_TYPE_CLOSE"  "$DISKUUID"  $EFFACE )

	[ $? -ne 0 ] && return

}

#=============================================================================
#
#  Function  clean ()
#
#=============================================================================
clean ()
{
  echo
  info_message  "clean '$VMNAME'"
  
  [ "$VERBOSE" ]  &&  echo  > /dev/stderr
  debug_message  "clean :  VMNAME='$VMNAME'"
  [ "$VMNAME" ]  ||  return
  
  LOCKFILE="$LOCKPATH"_"$VMNAME"
  
  wait_for_other_virtualbox_management_to_finish  clean
  info_message  "clean:  Retrieve VirtualBox info"
  INFOFILE=/tmp/$VMNAME.vbinfo
  ( [ "$VERBOSE" ]  &&  set -x
    "$VBMGT"  showvminfo  "$VMNAME"  --machinereadable  > "$INFOFILE" )
  if [ $? -ne 0 ] ; then
    warning_message  "clean :  Can NOT retrieve info for '$VMNAME'"
    exit 1
  fi
  [ "$VERBOSE" ]  &&  cat "$INFOFILE"  > /dev/stderr

    stop

  #---------------------------------------------------------------------------
  #  Detach Boot disk
  #---------------------------------------------------------------------------
  disk_dettach ${HDA1PORT} ${HDADEVICE}

  #---------------------------------------------------------------------------
  #  Detach Context disk, but delete it only in case of the vworker
  #---------------------------------------------------------------------------
  debug_message "clean '$VMNAME : disk_dettach ${CONTEXT_DISKPORT} ${HDBDEVICE}"
  disk_dettach ${CONTEXT_DISKPORT} ${HDBDEVICE}
  
  #---------------------------------------------------------------------------
  #  Detach and delete Application disk
  #---------------------------------------------------------------------------
  debug_message "clean '$VMNAME : disk_dettach ${APP_DISKPORT} ${HDBDEVICE}"
  disk_dettach ${APP_DISKPORT} ${HDBDEVICE}

  #---------------------------------------------------------------------------
  #  Detach and delete Input files disk
  #---------------------------------------------------------------------------
  debug_message "clean '$VMNAME : disk_dettach ${INPUT_DISKPORT} ${HDBDEVICE}"
  disk_dettach ${INPUT_DISKPORT} ${HDBDEVICE}

  #---------------------------------------------------------------------------
  #  Detach Results disk, but delete it only in case of the vworker
  #---------------------------------------------------------------------------
  debug_message "clean '$VMNAME : disk_dettach ${RESULT_DISKPORT} ${HDBDEVICE}"
  disk_dettach ${RESULT_DISKPORT} ${HDBDEVICE}

  #---------------------------------------------------------------------------
  #  Unregister the Virtual image
  #---------------------------------------------------------------------------
  wait_for_other_virtualbox_management_to_finish  clean
  info_message  "clean:  Unregister Virtual image '$VMNAME'"
  ( [ "$VERBOSE" ]  &&  set -x
    "$VBMGT"  unregistervm  "$VMNAME"  --delete )
  
  #---------------------------------------------------------------------------
  info_message  "clean:  delete disks"
  #---------------------------------------------------------------------------
  sleep  "$WAITDELAY"
#  CFGFILE="$(grep CfgFile "$INFOFILE"  |  cut  -d \"  -f 2)"
  CFGFILE="$(grep "Config file" "$INFOFILE"  |  cut  -d :  -f 2)"
  CFGDIR=`dirname "$CFGFILE"`
  [ -d "$CFGDIR" ] &&  debug_message  "clean '$VMNAME' :  deleting $CFGDIR"   &&  rm  -Rf  "$CFGDIR"
  
  rm  -f  "$LOCKFILE"
  rm  -f  "$INFOFILE"
}


#=============================================================================
#
#  Function  fatal (Message, Force)
#
#=============================================================================
fatal ()
{
  msg="$1"
  FORCE="$2"
  [ "$msg" ]  ||  msg="Ctrl+C"
#  sleep "$WAITDELAY"
  
  echo  "$(date "$DATE_FORMAT")  $SCRIPTNAME  FATAL : $msg"
  
  [ "$UNINSTALL" = "TRUE"  -o  "$FORCE" = "TRUE" ]  &&  clean
  
  ( [ "$VERBOSE" ]  &&  set -x
    "$VBMGT"  controlvm  "$VMNAME"  poweroff  > /dev/null 2>&1 )
  #
  # Inside 'fatal', the VM state is unknown and possibly inconsistent.
  # So, the above 'poweroff' request does NOT make much sense.
  
  exit 1
}


#=============================================================================
#
#  Main
#
#=============================================================================
trap  fatal  SIGINT  SIGTERM

echo
info_message  Begin
[ "$VERBOSE" ]  &&  echo  > /dev/stderr
debug_message  "Full script path is '$0'"


[ "$XWJOBUID" ]              ||  fatal  "XWJOBUID is not set"  TRUE

#
# this is the VM name
#
[ -z "$VMNAME" ]             &&  VMNAME="xwvm$XWJOBUID"


#
# uninstall VM
#
[ "$UNINSTALL" = "TRUE" ]  &&  clean

exit 0
###########################################################
#     EOF        EOF     EOF        EOF     EOF       EOF #
###########################################################
