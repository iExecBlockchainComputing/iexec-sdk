#!/bin/sh
#=============================================================================
#
#  File    : xwstartvm.sh
#  Date    : November, 2011
#  Author  : Oleg Lodygensky
#
#  Change log:
#  - august 6th,2013 : Etienne Urbah
#  - July 18th, 2013 : Oleg Lodygensky
#  - jan 13th, 2014  : Oleg Lodygensky
#    - ide controller replaced by sata
#    - VM used to have only one disk, the "scratch" disk
#      this scratch disk is replaced by 3 different disks
#      VM now has up to three disks : application disk (optional), input disk (optional) and result disk
#      if result disk is not provided, a default 10Gb one is created
#  - sept 30th, 2014  : Oleg Lodygensky
#    - Correcting volume mountage incoherency.
#      All VM now have 4 disks: context, app, input and results.
#      Because, if one is missing, disks may be mounted in incoherent mount point.
#      (e.g. if no app disk is provided, input disk may be mounted on /mnt/app instead of /mnt/input) 
#      To be more readable, disk ports are now fixed:
#      * context     disk is attached to disk port 1
#      * application disk is attached to disk port 2
#      * input       disk is attached to disk port 3
#      * result      disk is attached to disk port 4
# - Oct 24th, 2014 : Oleg Lodygensky
#   Get kernel console for debugging boot process, if needed
#     sl6[2|4]_createlivecd.ks bootloader options : bootloader --location=mbr --driveorder=sda --append="selinux=0 console=ttyS0 console=tty0 ignore_loglevel"
#     See SERIALOUT
#     Ref : https://www.virtualbox.org/wiki/Serial_redirect
#  - dec 5th, 2014  : modified by Oleg Lodygensky
#    - enabling VirtualBox shared file systems
#    - the worker can not create ISO files since this requires administrator privileges
#      hence createsiso script is not used any more
#
#  OS      : Linux, mac os x
# 
#  Purpose : this script creates and starts a new VirtualBox VM on worker side
#
# Two env variables must be set when calling this script : 
# (they are automatically set by the worker)
#  - XWSCRATCHPATH : this must contains the directory where drive are stored
#
# 
#  !!!!!!!!!!!!!!!!    DO NOT EDIT    !!!!!!!!!!!!!!!!
#  Remarks : this script is auto generated by install process
#
#=============================================================================


# Copyrights     : CNRS
# Author         : Oleg Lodygensky
# Acknowledgment : XtremWeb-HEP is based on XtremWeb 1.8.0 by inria : http://www.xtremweb.net/
# Web            : http://www.xtremweb-hep.org
# 
#      This file is part of XtremWeb-HEP.
#
#    XtremWeb-HEP is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    XtremWeb-HEP is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with XtremWeb-HEP.  If not, see <http://www.gnu.org/licenses/>.
#
#


#  ******************************************************************
#   WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN 
#
#    HDA1 file is deleted by clean() method
#
#   WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN 
#  ******************************************************************


#=============================================================================
#
#  Global variables
#
#qemu-system-x86_64 -m 2048 -cdrom xwhd2016-01-05-14-06-29-livecd-sl64.iso -net user,hostfwd=tcp::10022-:22 -net nic
#=============================================================================
SCRIPTNAME="$0"
if [ "${SCRIPTNAME#*.sh}" ]; then
  SCRIPTNAME=xwstartvm.sh
  VERBOSE=TRUE
  TESTINGONLY=''                         # Worker, so debug is NOT possible
else
  VERBOSE=''
  TESTINGONLY=TRUE                       # Local machine, so debug is possible
fi

ROOTDIR="$(dirname "$0")"


VBROOT=/Applications/VirtualBox.app/Contents/MacOS/
VBMGT="$VBROOT/VBoxManage"
VBHL="$VBROOT/VBoxHeadLess"
#VBHL="$VBROOT/VirtualBox"

LOCKNAME=xwvm.lock
LOCKDIR=/tmp/
LOCKPATH="$LOCKDIR/$LOCKNAME"

# machines dir
VBMDIR="/tmp"
VBMDIR1="/tmp"
VBMDIR2="/tmp"
# disks disk
VBHDIR="/tmp"

VMOSTYPE=Linux26_64

#
# This is the RAM size
# Default : 512Mb
# May be overidden by XWRAMSIZE env var
#
VMRAM=512

VMCPUS=1
VMSTORAGECTRLNAME=sata_ctrl
VMSTORAGECTRLTYPE=sata

#
# These are the commands to execute
# this is set by --install command line parameter
INSTALL="TRUE"
# this is set by --uninstall command line parameter
UNINSTALL="TRUE"
# this is set by --start command line parameter
START="TRUE"
# this is set by --stop command line parameter
STOP="TRUE"

VWORKERDISKTRAILERNAME="vworker"
RESULTDISKTRAILERNAME="result"

#
# This is the working disk size
# Default : 30Mb
# May be overidden by XWDISKSPACE env var
#
SCRATCHSIZE=30

WAITDELAY=2

HDTYPE="hdd"
DVDTYPE="dvddrive"
HDTYPECLOSE="disk"
DVDTYPECLOSE="dvd"


HDADEVICE=0
HDA1PORT=0

SHAREDFS=""
SHAREDFSNAME="xwsharedfs"


#####################################################################
# Since Jul 7th, 2014, VDI creation has been moved to an external
# script to avoid code duplication
#   * createdvdi
#
# For the worker: RPM, DEB and Apple packages
#   * install :  $XWHOME_DIR/bin/createvdi 
#   * create  :  two sym links : /usr/bin/xwcreatevdi
# For the worker: linux packages
#   * add the following line to /etc/sudoers
#       "xwhep ALL=NOPASSWD: /usr/bin/xwcreatevdi"
#####################################################################
CREATEVDISCRIPTNAME=createvdi
XWCREATEVDISCRIPTNAME=xwcreatevdi
# next is the path when installed from installation package
CREATEVDI="/usr/bin/$XWCREATEVDISCRIPTNAME"
# next is the path when using the source package
[ ! -x $CREATEVDI ] && CREATEVDI="/usr/local/bin/$CREATEVDISCRIPTNAME"
[ ! -x $CREATEVDI ] && CREATEVDI="$ROOTDIR/$CREATEVDISCRIPTNAME"
if [ ! -x $CREATEVDI ] ; then
  echo  "`date`  $SCRIPTNAME  FATAL : can't find $XWCREATEVDISCRIPTNAME"
  exit 1
fi

#####################################################################
#
#  The following variable is set by xwaddvbapp.sh script
#  It may also be set by --hda command line parameter
#
#  This is the main bootable virtual drive
#  This must be set
#  This may be an ISO, VDI, VHD or VMDK file
#
#  ******************************************************************
#   WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN 
#
#    This file is deleted by clean() method
#
#   WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN WARN 
#  ******************************************************************
HDA1FILE=""
#####################################################################


#HDBDEVICE=1
# 13 janvier 2014: using sata and not ide
# HDBDEVICE must be 0 since we use one SATA hardware only
HDBDEVICE=0
CONTEXT_DISKPORT=1
APP_DISKPORT=2
INPUT_DISKPORT=3
RESULT_DISKPORT=4

HDB1FILE_CONTEXT=""
HDB2FILE_APP=""
HDB3FILE_INPUT=""
HDB4FILE_OUTPUT=""


#
# XWPORTS is the env var that may contain a comma separated ports list
#
# NAT ssh port forwarding localhost:$XWPORTS[0] to guest:22
#
SSHLOCALPORT=
SSHGUESTPORT=22
#
# NAT http port forwarding localhost:$XWPORTS[1] to guest:80
#
HTTPLOCALPORT=
HTTPGUESTPORT=80

THISOS=`uname -s`

case "$THISOS" in
  
  Darwin )
    DATE_FORMAT='+%Y-%m-%d %H:%M:%S%z'
    VBROOT=/Applications/VirtualBox.app/Contents/MacOS/
    VBMGT="$VBROOT/VBoxManage"
    VBHL="$VBROOT/VBoxHeadLess"
    VBMDIR="$HOME/Library/VirtualBox/Machines"
    VBMDIR1="$HOME/Library/VirtualBox/"
    VBMDIR2="$HOME/VirtualBox VMs"
    VBHDIR="$HOME/Library/VirtualBox/HardDisks"
    ;;
  
  Linux )
    DATE_FORMAT='--rfc-3339=seconds'
    VBROOT=/usr/bin
    VBMGT="$VBROOT/vboxmanage"
    VBHL="$VBROOT/vboxheadless"
    VBMDIR="$HOME/Library/VirtualBox/Machines"
    VBMDIR1="$HOME/Library/VirtualBox/Machines"
    VBMDIR2="$HOME/VirtualBox VMs"
    VBHDIR="$HOME/Library/VirtualBox/HardDisks"
	CREATEVDI="sudo /usr/bin/$XWCREATEVDISCRIPTNAME"
    ;;
  
  * )
    fatal  "OS not supported ($THISOS)"  TRUE
    ;;
  
esac


VBREQUIREDVERSION="5.1"

VBVERSION="$("$VBMGT"  -v  |  cut  -d .  -f 1-2)"


#=============================================================================
#
#  Function  usage ()
#
#=============================================================================
usage()
{
  cat << END_OF_HELP

Usage : $0 --install --name vm_name --hda aFile [install_parameters] | --start --name vm_name | --stop --name vm_name | --uninstall --name vm_name

When running on the Grid Computing, commands are automatically and sequentially executed as follow
 [1] install --hda aFile [install_parameters]
 [2] start
 [3] stop
 [4] uninstall


--install --name vm_name --hda aFile [--context aFile] [--app aFile] [--input aFile] [--result aFile] [--sshport portNumber] [--sharedfs aDirectory]
    This installs a new VM in VirtualBox and exits.
    Install parameters:
    --hda     aFile : This is required
                      This provides the boot disk (an ISO, VDI, VMDK or VHD)
                      
    --context aFile : This is optional
                      This provides a file or a directory as context
                      If this is not a virtual disk (VD), a new VD is created containing aFile (recursively, if applicable)
                      If this is a VD (an ISO, VDI, VMDK or VHD), it is kept as is
                      The VD will be mounted on /mnt/xwcontext
                      
    --app aFile     : This is optional
                      This provides a virtual disk (VD) file to mount on /mnt/app
                      This file may be ISO, VDI, VMDK or VHD file
                      This typically contains user application stack
                      This is removed at VM shutdown
                      
    --input aFile   : This is optional
                      This provides a virtual disk (VD) file to mount on /mnt/input
                      This file may be ISO, VDI, VMDK or VHD file
                      This typically contains user application input files
                      This is removed at VM shutdown
                      
    --result aFile  : This is optional 
                      This provides a virtual disk (VD) file to mount on /mnt/result
                      This file may be ISO, VDI, VMDK or VHD file
                      If not provided, the script creates, formats 
                      and mounts a new empty 30Gb disk
                      This will contain user application results
                      This is kedpt at VM shutdown and sent back to user
                      
    --sharedfs      : This is optional
                      This provides a local directory to be mounted inside the VM on /mnt/sharedfs
					  This is forced to $XWSCRATCHPATH, when running on the Grid Computing
    --sshport       : This is optional 
                      This provides a port number to forward to VM port 22, to connect through ssh

--start --name vm_name
    This starts vm_name

--stop --name vm_name
    This stops vm_name

--uninstall --name vm_name
    This uninstalls vm_name from VirtualBox

END_OF_HELP
  
  exit 0
}


#=============================================================================
#  Function  debug_message (Message part, ...)
#=============================================================================
debug_message ()
{
  [ "$VERBOSE" ]  ||  return
  echo  "$(date "$DATE_FORMAT")  $SCRIPTNAME  DEBUG: " "$@"  > /dev/stderr
}


#=============================================================================
#  Function  info_message (Message part, ...)
#=============================================================================
info_message ()
{
  echo  "$(date "$DATE_FORMAT")  $SCRIPTNAME  INFO: " "$@"
}


#=============================================================================
#  Function  warning_message (Message part, ...)
#=============================================================================
warning_message ()
{
  echo  "$(date "$DATE_FORMAT")  $SCRIPTNAME  WARNING: " "$@"
}


#=============================================================================
#  Function  wait_for_other_virtualbox_management_to_finish (function_name)
#=============================================================================
wait_for_other_virtualbox_management_to_finish ()
{
  debug_message  "$1 '$VMNAME' :  Wait for other VirtualBox management to finish"
  debug_message  "$1 '$VMNAME' :  ps  -e  -o user,pid,args  |  grep ${VBMGT##*/}"
  while  ps  -e  -o user,pid,args  |  grep -v grep  |  \
                                      grep "${VBMGT##*/}"  > /dev/stderr; do
  debug_message  "$1 '$VMNAME' :  Sleep 10"
	
    ( [ "$VERBOSE" ]  &&  set -x
      sleep 10 )
  done
}


#=============================================================================
#  Function  stop ()
#=============================================================================
stop ()
{
  echo
  info_message  "stop '$VMNAME'"
  
  [ "$VERBOSE" ]  &&  echo  > /dev/stderr
  wait_for_other_virtualbox_management_to_finish  stop

#  VM_STATE="$("$VBMGT"  showvminfo  "$VMNAME"  --machinereadable  |  \
#         grep  '^State=' )"
#  debug_message  "stop :  VM_STATE='$VM_STATE'"
  
 # echo $VM_STATE | grep "powered off" > /dev/null 2>&1
 # if [ $? -eq 0 ]; then
 #   info_message  "stop:  Already stopped"
 # else
#    echo $VM_STATE | grep -E "aborted|saved" > /dev/null 2>&1
#    if [ $? -eq 0 ]; then
      info_message  "stop:  restarting to be sure we can stop (regardless the machine state)"
      ( [ "$VERBOSE" ]  &&  set -x
        "$VBHL"  --startvm  "$VMNAME" )  &
      sleep 5
#    fi
    info_message  "stop:  Stopping"
    ( [ "$VERBOSE" ]  &&  set -x
      "$VBMGT"  controlvm  "$VMNAME"  poweroff )
#  fi
}


#=============================================================================
#
#  Function  calculate_disk_type_in_function_of_suffix (DISK_FILENAME)
#
#  Variables set:  DISK_TYPE
#                  DISK_TYPE_CLOSE
#
#=============================================================================
calculate_disk_type_in_function_of_suffix ()
{
  DISK_EXT="${1##*.}"
  
  if [ "$DISK_EXT" = "iso" ]; then
      DISK_TYPE="$DVDTYPE"
      DISK_TYPE_CLOSE="$DVDTYPECLOSE"
      
  elif [ '(' "$DISK_EXT" = "vdi"  ')'  -o  \
         '(' "$DISK_EXT" = "vmdk" ')'  -o  \
         '(' "$DISK_EXT" = "vhd"  ')' ]; then
      DISK_TYPE="$HDTYPE"
      DISK_TYPE_CLOSE="$HDTYPECLOSE"
      
  else
      DISK_TYPE=""
      DISK_TYPE_CLOSE=""
      
  fi
}

#=============================================================================
#
# Function  disk_attach ()
# This attaches a disk; this may create a new empty disk, if $3 is TRUE
# @param $1 : informative text
# @param $2 : virtual disk file
# @param $3 : device port number
# @param $4 : if TRUE, create a new empty disk (not used)
#
#=============================================================================
disk_attach () 
{
	DTEXT=$1
	DFILE=$2
	DEVICEPORT=$3
#	CREATE="TRUE"
	NEWDISK="FALSE"

	#---------------------------------------------------------------------------
	#  Results disk or new disk with free space
	#---------------------------------------------------------------------------
	if [ -z "$DFILE" ]; then
#		if [ "$CREATE" = "TRUE" ]; then
			#-------------------------------------------------------------------------
			info_message  "disk_attach '${DTEXT}':  create new disk (${SCRATCHSIZE}Mb)"
			#-------------------------------------------------------------------------
			DFILE="$XWSCRATCHPATH/xwhd${XWJOBUID}-${DTEXT}.vdi"
			#
			# This is for the vworker (the virtualized worker)
			#
			[ -d "$XWSCRATCHPATH/../vdi/" ]  &&  \
			  DFILE="$XWSCRATCHPATH/../vdi/xwhd$XWJOBUID.vdi"

			wait_for_other_virtualbox_management_to_finish  install
			debug_message  "install '$VMNAME' :   '$DFILE' :  createhd"
			( [ "$VERBOSE" ]  &&  set -x
			  "$VBMGT"  createmedium  \
				--filename "$DFILE" \
				--size     "$SCRATCHSIZE" )  ||  \
			  fatal "disk_attach '${DTEXT}': can not create new disk '$DFILE'"  TRUE

			NEWDISK="TRUE"

#		else
#			#-------------------------------------------------------------------------
#			info_message  "disk_attach '${DTEXT}':  not creating/attaching any new disk"
#			#-------------------------------------------------------------------------
#			return
#		fi
	else
		if [ -r "${DFILE}" ] ; then
			download_if_http  "$DFILE"
			DFILE="$FILE_LOCAL"
		else
			DFILE=""
		fi
	fi

	if [ ! -r "${DFILE}" ] ; then
		info_message  "disk_attach '${DTEXT}':  can't read disk ${DFILE}"
		return
	fi

	#-------------------------------------------------------------------------
	info_message  "disk_attach '${DTEXT}' :  ${DFILE}"
	#-------------------------------------------------------------------------

	{ echo  "$DFILE"  |  grep  -E '\.(iso|vdi|vmdk|vhd)$'  > /dev/null 2>&1 ; }  ||  \
		fatal  "disk_attach '${DFILE}' :  Incompatible disk type"  TRUE

	calculate_disk_type_in_function_of_suffix  "$DFILE"

	#-----------------------------------------------------------------------
	#  Rename the Results disk and set a new UUID for non ISO,
	#  in order to be able to launch several simultaneous VM using
	#  the same disk
	#-----------------------------------------------------------------------
	DIRNAME="$(dirname "$DFILE")"
#	if [ "$CREATE" != "TRUE" ]; then
#		TMPFILE="$DIRNAME/xwhd$XWJOBUID-$DFILENAME"
#		mv  "$DFILE"  "$TMPFILE"
#		DFILE="$TMPFILE"
#	fi

	if [ "$DISK_TYPE" != "$DVDTYPE" ] ; then
		wait_for_other_virtualbox_management_to_finish  install
		debug_message  "disk_attach '${DTEXT}' :  setuuid '$DFILE'"
		[ "$NEWDISK" = "FALSE" ] &&  (  [ "$VERBOSE" ]  &&  set -x "$VBMGT"  internalcommands  sethduuid  "$DFILE" )
	fi

	if [ -z "$DFILE" ]; then
		fatal  "disk_attach '${DTEXT}' : no disk found"  TRUE
	fi
	#---------------------------------------------------------------------------
	info_message  "disk_attach '${DTEXT}' :  attach disk '$DFILE' to ${VMSTORAGECTRLNAME} ${HDBDEVICE} ${DEVICEPORT} ${DISK_TYPE}"
	#---------------------------------------------------------------------------
	wait_for_other_virtualbox_management_to_finish  install
 	[ "$VERBOSE" ]  &&  set -x && echo DEVICEPORT="$DEVICEPORT"
		"$VBMGT"  storageattach  "${VMNAME}" \
		--storagectl ${VMSTORAGECTRLNAME}    \
		--port	   ${DEVICEPORT}        \
    	--device   ${HDBDEVICE}              \
    	--type     ${DISK_TYPE}              \
    	--medium     "${DFILE}"
	if [ $? -ne 0 ] ; then
    	rm -f "$DFILE"
    	fatal  "disk_attach '${DTEXT}' : can not attach disk '$DFILE'"  TRUE
	fi
}

#=============================================================================
#
#  Function  disk_dettach ()
# This dettaches a disk and deletes it, if not virtualized worker
# @param $1 : port number
# @param $2 : device number
#
#=============================================================================
disk_dettach () 
{
	PORT=$1
	DEVICE=$2

	DISKFILE="$(grep ${VMSTORAGECTRLNAME}-${PORT}-${DEVICE} "$INFOFILE"  |  cut  -d \"  -f 4)"
	DISKUUID="$(grep ${VMSTORAGECTRLNAME}-ImageUUID-${PORT}-${DEVICE} "$INFOFILE"  |  cut  -d \"  -f 4)"


	if [ "X$DISKFILE" = "X" ] ; then
		info_message  "disk_dettach : can't find disk file ($1 $2 $3)"
		return
	fi

	info_message  "disk_dettach $VMNAME : $DISKFILE $DISKUUID"

	calculate_disk_type_in_function_of_suffix  "$DISKFILE"

  [ "$VERBOSE" ]  &&  cat  << END_OF_DISKDETTACH_VARS  > /dev/stderr
	VMNAME="$VMNAME"
	PORT=$PORT
	DEVICE=$DEVICE
	DISK_TYPE=$DISK_TYPE
	DISK_TYPE_CLOSE=$DISK_TYPE_CLOSE
	DISKFILE=$DISKFILE
	DISKUUID=$DISKUUID
END_OF_DISKDETTACH_VARS

#
# dettach drive
#
	wait_for_other_virtualbox_management_to_finish  disk_dettach
	( [ "$VERBOSE" ]  &&  set -x
		"$VBMGT"  storageattach  "$VMNAME"  \
		--storagectl "$VMSTORAGECTRLNAME" \
		--port       "$PORT"  \
		--device     "$DEVICE" \
		--type       "$DISK_TYPE"  \
		--medium     none )
	
	[ $? -ne 0 ] && return

	EFFACE='--delete'
#
# keep result disk
#
	{ echo "$DISKFILE"  |  grep "${RESULTDISKTRAILERNAME}"  > /dev/null 2>&1 ; }  &&  \
		EFFACE=""
#
# if it is a virtualized worker (vworker), delete
#
	{ echo "$DISKFILE"  |  grep "${VWORKERDISKTRAILERNAME}"  > /dev/null 2>&1 ; }  &&  \
		EFFACE="--delete"

    [ "$TESTINGONLY" = "TRUE" ] && EFFACE=""

    wait_for_other_virtualbox_management_to_finish  disk_dettach
	debug_message  "dettach disk '$VMNAME' : closemedium  $DISK_TYPE_CLOSE'  '$DISKFILE'  $EFFACE"
	( [ "$VERBOSE" ]  &&  set -x
	 "$VBMGT"  closemedium  "$DISK_TYPE_CLOSE"  "$DISKUUID"  $EFFACE )

	[ $? -ne 0 ] && return

}

#=============================================================================
#
#  Function  clean ()
#
#=============================================================================
clean ()
{
  echo
  info_message  "clean '$VMNAME'"
  
  [ "$VERBOSE" ]  &&  echo  > /dev/stderr
  debug_message  "clean :  VMNAME='$VMNAME'"
  [ "$VMNAME" ]  ||  return
  
  LOCKFILE="$LOCKPATH"_"$VMNAME"
  
  wait_for_other_virtualbox_management_to_finish  clean
  info_message  "clean:  Retrieve VirtualBox info"
  INFOFILE=/tmp/$VMNAME.vbinfo
  ( [ "$VERBOSE" ]  &&  set -x
    "$VBMGT"  showvminfo  "$VMNAME"  --machinereadable  > "$INFOFILE" )
  if [ $? -ne 0 ] ; then
    warning_message  "clean :  Can NOT retrieve info for '$VMNAME'"
    exit 1
  fi
  [ "$VERBOSE" ]  &&  cat "$INFOFILE"  > /dev/stderr

#  if [ "$(grep  '^VMState='  "$INFOFILE"  |  cut  -d \"  -f 2)" !=  \
#       "poweroff" ]; then
 
#  grep  '^State:'  $INFOFILE  |  grep 'powered off' > /dev/null  2>&1
#  if [ $? -ne 0 ]; then
    stop
#    [ "$VERBOSE" ]  &&  echo  > /dev/stderr
#  fi

  #---------------------------------------------------------------------------
  #  Detach Boot disk
  #---------------------------------------------------------------------------
  disk_dettach ${HDA1PORT} ${HDADEVICE}

  #---------------------------------------------------------------------------
  #  Detach Context disk, but delete it only in case of the vworker
  #---------------------------------------------------------------------------
  debug_message "clean '$VMNAME : disk_dettach ${CONTEXT_DISKPORT} ${HDBDEVICE}"
  disk_dettach ${CONTEXT_DISKPORT} ${HDBDEVICE}
  
  #---------------------------------------------------------------------------
  #  Detach and delete Application disk
  #---------------------------------------------------------------------------
  debug_message "clean '$VMNAME : disk_dettach ${APP_DISKPORT} ${HDBDEVICE}"
  disk_dettach ${APP_DISKPORT} ${HDBDEVICE}

  #---------------------------------------------------------------------------
  #  Detach and delete Input files disk
  #---------------------------------------------------------------------------
  debug_message "clean '$VMNAME : disk_dettach ${INPUT_DISKPORT} ${HDBDEVICE}"
  disk_dettach ${INPUT_DISKPORT} ${HDBDEVICE}

  #---------------------------------------------------------------------------
  #  Detach Results disk, but delete it only in case of the vworker
  #---------------------------------------------------------------------------
  debug_message "clean '$VMNAME : disk_dettach ${RESULT_DISKPORT} ${HDBDEVICE}"
  disk_dettach ${RESULT_DISKPORT} ${HDBDEVICE}

  #---------------------------------------------------------------------------
  #  Unregister the Virtual image
  #---------------------------------------------------------------------------
  wait_for_other_virtualbox_management_to_finish  clean
  info_message  "clean:  Unregister Virtual image '$VMNAME'"
  ( [ "$VERBOSE" ]  &&  set -x
    "$VBMGT"  unregistervm  "$VMNAME"  --delete )
  
  #---------------------------------------------------------------------------
  info_message  "clean:  delete disks"
  #---------------------------------------------------------------------------
  sleep  "$WAITDELAY"
#  CFGFILE="$(grep CfgFile "$INFOFILE"  |  cut  -d \"  -f 2)"
  CFGFILE="$(grep "Config file" "$INFOFILE"  |  cut  -d :  -f 2)"
  CFGDIR=`dirname "$CFGFILE"`
  [ -d "$CFGDIR" ] &&  debug_message  "clean '$VMNAME' :  deleting $CFGDIR"   &&  rm  -Rf  "$CFGDIR"
  
  rm  -f  "$LOCKFILE"
  rm  -f  "$INFOFILE"
}


#=============================================================================
#
#  Function  fatal (Message, Force)
#
#=============================================================================
fatal ()
{
  msg="$1"
  FORCE="$2"
  [ "$msg" ]  ||  msg="Ctrl+C"
#  sleep "$WAITDELAY"
  
  echo  "$(date "$DATE_FORMAT")  $SCRIPTNAME  FATAL : $msg"
  
  [ "$UNINSTALL" = "TRUE"  -o  "$FORCE" = "TRUE" ]  &&  clean
  
  ( [ "$VERBOSE" ]  &&  set -x
    "$VBMGT"  controlvm  "$VMNAME"  poweroff  > /dev/null 2>&1 )
  #
  # Inside 'fatal', the VM state is unknown and possibly inconsistent.
  # So, the above 'poweroff' request does NOT make much sense.
  
  exit 1
}


#=============================================================================
#
#  Function  download_if_http ()
#
#  Download an URI beginning with 'http(s)://', and unzip it if necessary
#
#  Parameter :     FILE_REF :    File reference, possibly beginning with
#                                'http(s)://'
#
#  Variable set :  FILE_LOCAL :  Name of the locally downloaded (and unzipped)
#                                file
#
#=============================================================================
download_if_http ()
{
  FILE_REF="$1"
  FILE_LOCAL="$FILE_REF"
  
  if expr "$FILE_REF" : 'https*://' > /dev/null; then
    FILE_LOCAL="${FILE_LOCAL%%[/?]download}"
    FILE_LOCAL="${FILE_LOCAL##*/}"
    FILE_LOCAL="${FILE_LOCAL##*&filename=}"
    ( [ "$VERBOSE" ]  &&  { echo > /dev/stderr;  set -x; }
      wget  -nv  -O "$FILE_LOCAL"  "$FILE_REF" )  ||  \
      fatal  "Downloading '$FILE_REF' FAILED"  TRUE
    
    FILE_LOCAL_WITHOUT_ZIP="${FILE_LOCAL%.[Zz][Ii][Pp]}"
    if [ "$FILE_LOCAL_WITHOUT_ZIP" != "$FILE_LOCAL" ]; then
      ( [ "$VERBOSE" ]  &&  set -x
        unzip  -o  "$FILE_LOCAL"  "$FILE_LOCAL_WITHOUT_ZIP" )
      FILE_LOCAL="$FILE_LOCAL_WITHOUT_ZIP"
    fi
    
  fi
}


#=============================================================================
#
#  Function  install ()
#
#=============================================================================
install ()
{
  echo
  info_message  "install '$VMNAME'"

  if [ -n "$HDB1FILE_CONTEXT" ] ; then 
	HDB1FILE_CONTEXT_SAV=$HDB1FILE_CONTEXT
	HDB1FILE_CONTEXT=`$CREATEVDI --src $HDB1FILE_CONTEXT`
	[ $? -ne 0 ] && fatal "Can't create context disk from $HDB1FILE_CONTEXT_SAV"
  else
	warning_message  "install :  no contextualization disk provided"
  fi

  if [ -n "$HDB2FILE_APP" ] ; then
  	HDB2FILE_APP_SAV=$HDB2FILE_APP
	HDB2FILE_APP=`$CREATEVDI --src  $HDB2FILE_APP`
	[ $? -ne 0 ] && fatal "Can't create application disk from $HDB2FILE_APP_SAV"
  fi

  if [ -n "$HDB3FILE_INPUT" ] ; then 
  	HDB3FILE_INPUT_SAV=$HDB3FILE_INPUT
	HDB3FILE_INPUT=`$CREATEVDI --src  $HDB3FILE_INPUT`
	[ $? -ne 0 ] && fatal "Can't create input disk from $HDB3FILE_INPUT_SAV"
  fi

  if [ -n "$HDB4FILE_OUTPUT" ] ; then
  	HDB4FILE_OUTPUT=`$CREATEVDI --src $HDB4FILE_OUTPUT`
  fi

  [ $? -ne 0 ] && fatal "Can't create output disk from $HDB4FILE_OUTPUT"

 
  [ "$VERBOSE" ]  &&  echo  > /dev/stderr
  debug_message  "install '$VMNAME' :  HDA1FILE='$HDA1FILE'"
  [ "$HDA1FILE" ]  ||  fatal  "$HDA1FILE not set"  
  
  debug_message  "install '$VMNAME' :  Initial values of variables :"
  [ "$VERBOSE" ]  &&  cat  << END_OF_INSTALL_VARS  > /dev/stderr
VMNAME="$VMNAME"
SCRATCHSIZE="$SCRATCHSIZE Mb"
XWSCRATCHPATH="$XWSCRATCHPATH"
XWCPULOAD="$XWCPULOAD"
XWJOBUID="$XWJOBUID"
XWDIRINPATH="$XWDIRINPATH"
XWSTDINPATH="$XWSTDINPATH"
XWLIBPATH="$XWLIBPATH"
XWBINPATH="$XWBINPATH"
XWPORTS="$XWPORTS"
HDA1FILE="$HDA1FILE"
HDB1FILE_CONTEXT="$HDB1FILE_CONTEXT"
HDB2FILE_APP="$HDB2FILE_APP"
HDB3FILE_INPUT="$HDB3FILE_INPUT"
HDB4FILE_OUTPUT="$HDB4FILE_OUTPUT"
END_OF_INSTALL_VARS
  
  download_if_http  "$HDA1FILE"
  HDA1FILE="$FILE_LOCAL"
  if [ ! -f "$HDA1FILE" ] ; then
      HDA1FILE="$XWSCRATCHPATH/$HDA1FILE"
  fi
  if [ ! -f "$HDA1FILE" ] ; then
      fatal  "HDA1 file not found : '$HDA1FILE'"  TRUE
  fi
  
  if [ -n "$HDB1FILE_CONTEXT" ] ; then
    download_if_http  "$HDB1FILE_CONTEXT"
    HDB1FILE_CONTEXT="$FILE_LOCAL"
    if [ ! -f "$HDB1FILE_CONTEXT" ] ; then
        HDB1FILE_CONTEXT="$XWSCRATCHPATH/$HDB1FILE_CONTEXT"
    fi
  fi
  
  #---------------------------------------------------------------------------
  # Let's unregister the Virtual image just in case...
  # This may happen if the worker has been killed and had no chance to clean everything
  # In such a case the VM has been aborted  and is in a very bad state
  # Finally the worker could not restart the same job because the VM would still be registered
  #---------------------------------------------------------------------------
  wait_for_other_virtualbox_management_to_finish  install
  info_message  "install:  Unregister any previous installation of '$VMNAME'"
  ( [ "$VERBOSE" ]  &&  set -x
    "$VBMGT"  showvminfo  "$VMNAME"  > /dev/null 2>&1 )  &&  \
    ( [ "$VERBOSE" ]  &&  set -x
      "$VBMGT"  unregistervm  "$VMNAME"  --delete )

  [ -d "$VBMDIR/$VMNAME"        ]  &&  debug_message  "clean '$VMNAME' :  Deleting '$VBMDIR/$VMNAME'"   &&  rm  -Rf  "$VBMDIR/$VMNAME"
  [ -d "$VBMDIR1/$VMNAME"       ]  &&  debug_message  "clean '$VMNAME' :  Deleting '$VBMDIR1/$VMNAME'"  &&  rm  -Rf  "$VBMDIR1/$VMNAME"
  [ -d "$VBMDIR2/$VMNAME"       ]  &&  debug_message  "clean '$VMNAME' :  Deleting '$VBMDIR2/$VMNAME'"  &&  rm  -Rf  "$VBMDIR2/$VMNAME"
  [ -d "$XWSCRATCHPATH/$VMNAME" ]  &&  debug_message  "clean '$VMNAME' :  Deleting '$VBMDIR2/$VMNAME'"  &&  rm  -Rf  "$XWSCRATCHPATH/$VMNAME"

  HDA1FILENAME="$(basename "$HDA1FILE")"
  HDA1DIRNAME="$(dirname "$HDA1FILE")"
  
  calculate_disk_type_in_function_of_suffix  "$HDA1FILENAME"
  [ -z "$DISK_TYPE" ]  &&  fatal  "$HDA1FILEMAME :  Extension '${HDA1FILENAME##*.}' NOT managed"  TRUE
  
  debug_message  "install '$VMNAME' :  HDA1FILENAME='$HDA1FILENAME'"
  debug_message  "install '$VMNAME' :  HDA1FILE='$HDA1FILE'"
  
  
  [ "$VBVERSION" = "$VBREQUIREDVERSION" ]  ||  \
     warning_message  "install:  VB version found '$VBVERSION'; expected '$VBREQUIREDVERSION'"
  
  
  arch=`uname -m`
  [ "X${arch}" = "Xx86_64" ] || VMOSTYPE="Linux26"
 
  #---------------------------------------------------------------------------
  info_message  "install:  create and register virtual machine '$VMNAME' (${VMOSTYPE})"
  #---------------------------------------------------------------------------
  BF=""
  [ "$XWSCRATCHPATH" ]  ||  BF="--basefolder $XWSCRATCHPATH"
  
  wait_for_other_virtualbox_management_to_finish  install
  debug_message  "install '$VMNAME' :  createvm"
  ( [ "$VERBOSE" ]  &&  set -x
    "$VBMGT"  createvm  --name "$VMNAME"  $BF  --ostype "$VMOSTYPE"  --register )  ||  \
      fatal  "Can NOT create Virtual image '$VMNAME'"  TRUE
  
  SERIALOUTFILE="$XWSCRATCHPATH"/"$VMNAME"_ttys0.txt
  [ -f ${SERIALOUTFILE} ] && mv ${SERIALOUTFILE} ${SERIALOUTFILE}-sav
  wait_for_other_virtualbox_management_to_finish  install
  debug_message  "install '$VMNAME' :  modifyvm"
  ( [ "$VERBOSE" ]  &&  set -x
    "$VBMGT"  modifyvm  "$VMNAME" \
      --memory "$VMRAM" \
      --acpi   on  \
      --pae    on  \
      --boot1  dvd \
      --uart1  "0x3f8" 4 \
      --uartmode1 file "$SERIALOUTFILE" \
      --nic1   nat )  ||  \
      fatal  "Can NOT modify Virtual image '$VMNAME'"  TRUE


  #---------------------------------------------------------------------------
  #  New disk controller
  #---------------------------------------------------------------------------
  wait_for_other_virtualbox_management_to_finish  install
  info_message  "install '$VMNAME' :  creating storagectl ${VMSTORAGECTRLNAME} ${VMSTORAGECTRLTYPE}"
  ( [ "$VERBOSE" ]  &&  set -x
    "$VBMGT"  storagectl  "$VMNAME" \
      --name  "$VMSTORAGECTRLNAME" \
      --add   $VMSTORAGECTRLTYPE )  ||  \
    fatal  "Can NOT create controller '$VMSTORAGECTRLNAME'"  TRUE
  
  
  #---------------------------------------------------------------------------
  #  Boot disk :
  #  Rename it and set a new UUID for non ISO, in order to be able to launch
  #  several simultaneous VM using the same Boot disk
  #---------------------------------------------------------------------------
  HDA1TMPFILE="$HDA1DIRNAME/xwhd$XWJOBUID-$HDA1FILENAME"
  debug_message  "install '$VMNAME' :  HDA1TMPFILE='$HDA1TMPFILE'"

  mv  "$HDA1FILE"  "$HDA1TMPFILE"
  HDA1FILE="$HDA1TMPFILE"
  
  if [ "$DISK_TYPE" != "$DVDTYPE" ] ; then
    wait_for_other_virtualbox_management_to_finish  install
    debug_message  "install '$VMNAME' :  '$HDA1FILE' :  sethduuid"
    ( [ "$VERBOSE" ]  &&  set -x
      "$VBMGT"  internalcommands  sethduuid  "$HDA1FILE" )
  fi
  
  debug_message  "install '$VMNAME' :  HDA1FILE renamed ='$HDA1FILE'"
  
  #---------------------------------------------------------------------------
  info_message  "install:  attach boot disk '$HDA1FILE' to ${VMSTORAGECTRLNAME} ${HDADEVICE} ${HDA1PORT} ${DISK_TYPE}"
  #---------------------------------------------------------------------------
  wait_for_other_virtualbox_management_to_finish  install
  ( [ "$VERBOSE" ]  &&  set -x
    "$VBMGT"  storageattach  "$VMNAME"  \
      --storagectl "$VMSTORAGECTRLNAME" \
      --port       "$HDA1PORT"  \
      --device     "$HDADEVICE" \
      --type       "$DISK_TYPE"  \
      --medium     "$HDA1FILE" )  ||  \
    fatal  "Can NOT attach Boot disk '$HDA1FILE'"  TRUE


  #---------------------------------------------------------------------------
  info_message  "install: contextualization disk ${HDB1FILE_CONTEXT}"
  #---------------------------------------------------------------------------
  if [ -n "$HDB1FILE_CONTEXT" ] ; then
	disk_attach "context" "${HDB1FILE_CONTEXT}" "${CONTEXT_DISKPORT}"
  else
	warning_message  "install :  no contextualization disk to attach"
  fi

  #---------------------------------------------------------------------------
  info_message  "install: application disk ${HDB2FILE_APP}"
  #---------------------------------------------------------------------------
  disk_attach "application" "${HDB2FILE_APP}" "${APP_DISKPORT}"

  #---------------------------------------------------------------------------
  info_message  "install: input file disk ${HDB3FILE_INPUT}"
  #---------------------------------------------------------------------------
  disk_attach "input" "${HDB3FILE_INPUT}" "${INPUT_DISKPORT}"

  #---------------------------------------------------------------------------
  info_message  "install: result disk ${HDB4FILE_OUTPUT}"
  #---------------------------------------------------------------------------
  disk_attach "${RESULTDISKTRAILERNAME}" "${HDB4FILE_OUTPUT}" "${RESULT_DISKPORT}" "TRUE"


  if [ -n "$SHAREDFS" -a -d $SHAREDFS ] ; then 
  #---------------------------------------------------------------------------
	  info_message  "install: result disk ${HDB4FILE_OUTPUT}"
  #---------------------------------------------------------------------------
	wait_for_other_virtualbox_management_to_finish  sharedfs
	( [ "$VERBOSE" ]  &&  set -x
    	"$VBMGT"  sharedfolder add  "$VMNAME"  \
		--name     "$SHAREDFSNAME" \
		--hostpath "$SHAREDFS")  ||  \
    fatal  "Can not attach sharedfs ($SHAREDFS)" TRUE
  fi


  info_message  "install:  Boot disk        ='$HDA1FILE'"
  info_message  "install:  Context disk     ='$HDB1FILE_CONTEXT'"
  info_message  "install:  Application disk ='$HDB2FILE_APP'"
  info_message  "install:  Input disk       ='$HDB3FILE_INPUT'"
  info_message  "install:  Output disk      ='$HDB4FILE_OUTPUT'"

  
  #---------------------------------------------------------------------------
  # Port forwarding
  #---------------------------------------------------------------------------
  if [ "$XWPORTS" ] ; then
    
    # XWPORTS must contain a comma
    if echo "$XWPORTS" | grep -v "," > /dev/null 2>&1 ; then
      XWPORTS="$XWPORTS,"
    fi
    
    SSHLOCALPORT="$(echo "$XWPORTS"  |  cut  -d ','  -f 1)"
    info_message  "install:  SSHLOCALPORT='$SSHLOCALPORT'"
    if [ "$SSHLOCALPORT" ] ; then
      wait_for_other_virtualbox_management_to_finish  install
      debug_message  "install '$VMNAME' :  natpf1 xwssh"
      ( [ "$VERBOSE" ]  &&  set -x
        "$VBMGT"  modifyvm  "$VMNAME"  --natpf1 "xwssh,tcp,,$SSHLOCALPORT,,$SSHGUESTPORT" )
    fi
    HTTPLOCALPORT="$(echo "$XWPORTS"  |  cut -d ','  -f 2)"
    info_message  "install:  HTTPLOCALPORT='$HTTPLOCALPORT'"
    if [ "$HTTPLOCALPORT" ] ; then
      wait_for_other_virtualbox_management_to_finish  install
      debug_message  "install '$VMNAME' :  natpf1 xwweb"
      ( [ "$VERBOSE" ]  &&  set -x
        "$VBMGT"  modifyvm  "$VMNAME"  --natpf1 "xwweb,tcp,,$HTTPLOCALPORT,,$HTTPGUESTPORT" )
    fi
    
  fi

  sleep  "$WAITDELAY"
}


#=============================================================================
#
#  Main
#
#=============================================================================
trap  fatal  SIGINT  SIGTERM

[ $# -gt 0 ] || usage

echo
info_message  Begin
[ "$VERBOSE" ]  &&  echo  > /dev/stderr
debug_message  "Full script path is '$0'"


while [ $# -gt 0 ]; do
  
  case "$1" in
  
    --help )
      usage
      ;;
    
    -v | --verbose | --debug )
      VERBOSE=1
      ;;
    
    --context )
      shift
      HDB1FILE_CONTEXT="$1"
      ;;
    
    --userapp | --userappli | --userapplication | --scratch | --app )
      shift
      HDB2FILE_APP="$1"
      ;;
    
    --userinput | --input )
      shift
      HDB3FILE_INPUT="$1"
      ;;
    
    --useroutput | --output | --result )
      shift
      HDB4FILE_OUTPUT="$1"
      ;;
    
    --sharedfs )
      shift
      if [ "$TESTINGONLY" = "TRUE" ] ; then
	      SHAREDFS=$1
	  else
	      SHAREDFS=$XWSCRATCHPATH
	  fi
	  [ -d $SHAREDFS ] || fatal  "ERROR : sharedfs ($SHAREDFS) is not a valid directory" TRUE
      ;;
    --sshport )
      shift
      if [ -z "$XWPORTS" ] ; then
        XWPORTS="$1"
      else
        warning_message  "Ports are set to '$XWPORTS'"
        warning_message  "ignoring --sshport $1"
      fi
      ;;
    
    --name | --install | --uninstall | --start | --boot | --bootdisk | --livecd | --liveCD | --hda | --stop )
      if [ "$TESTINGONLY" = "TRUE" ] ; then
        XWJOBUID="$(date '+%Y-%m-%d-%H-%M-%S')"
        XWSCRATCHPATH="$(dirname "$0")"
        SAVDIR=`pwd`
		cd "$XWSCRATCHPATH"
		XWSCRATCHPATH=`pwd`
		cd "$SAVDIR"
        XWCPULOAD=100
      else
        fatal  "NOT allowed : '$1'"  TRUE
      fi
      
      case "$1" in
        
        --name )
          shift
          VMNAME="$1"
          ;;
        
        --install )
          [ "$INSTALL" = "FALSE" ]    &&  \
            fatal  "Syntax error (you can NOT provide more than one command)"
          UNINSTALL=FALSE
          START=FALSE
          STOP=FALSE
          ;;
        
        --uninstall )
          [ "$UNINSTALL" = "FALSE" ]  &&  \
            fatal  "Syntax error (you can NOT provide more than one command)"
          INSTALL=FALSE
          START=FALSE
          STOP=FALSE
          ;;
        
        --start )
          [ "$START" = "FALSE" ]      &&  \
            fatal  "Syntax error (you can NOT provide more than one command)"
          UNINSTALL=FALSE
          INSTALL=FALSE
          STOP=FALSE
          ;;
        
        --stop )
          [ "$STOP" = "FALSE" ]       &&  \
            fatal  "Syntax error (you can NOT provide more than one command)"
          UNINSTALL=FALSE
          INSTALL=FALSE
          START=FALSE
          ;;
        
        --boot | --bootdisk | --livecd | --liveCD | --hda )
          shift
          HDA1FILE="$1"
          ;;
        
      esac
      
      ;;
    
  esac
  
  shift
  
done

[ "$XWJOBUID" ]              ||  fatal  "XWJOBUID is not set"  TRUE

#
# this is the VM name
#
[ -z "$VMNAME" ]             &&  VMNAME="xwvm$XWJOBUID"

[ "$XWCPULOAD" ]             ||  XWCPULOAD=50

[ -n "$XWDISKSPACE" ]           &&  SCRATCHSIZE="$XWDISKSPACE"
[ -n "$XWRAMSIZE"   ]           &&  VMRAM="$XWRAMSIZE"

[ "$INSTALL"  != "TRUE"  -o  \
  "$HDA1FILE" != "" ]        ||  fatal  "HDA1FILE not set"  TRUE

[ "$XWSCRATCHPATH" ]         ||  fatal  "XWSCRATCHPATH not set"  TRUE

debug_message  "Initial values of variables :"
[ "$VERBOSE" ]  &&  cat  << END_OF_MAIN_VARS  > /dev/stderr
INSTALL="$INSTALL"
UNINSTALL="$UNINSTALL"
START="$START"
VMNAME="$VMNAME"
HDA1FILE="$HDA1FILE"
XWCPULOAD="$XWCPULOAD"
XWSCRATCHPATH="$XWSCRATCHPATH"
END_OF_MAIN_VARS

#
# Install VM
#
[ "$INSTALL" = "TRUE" ]  &&  install

#
# start VM
#
if [ "$START" = "TRUE" ]; then
  [ "$VERBOSE" ]  &&  echo  > /dev/stderr
  wait_for_other_virtualbox_management_to_finish  start
  
  echo
  if [ "$("$VBMGT"  showvminfo  "$VMNAME"  --machinereadable  |  \
         grep  '^VMState='  |  cut  -d \"  -f 2)" = "running" ]; then
    info_message  "start '$VMNAME' :  Already running"
  else
    info_message  "start '$VMNAME'"
    ( [ "$VERBOSE" ]  &&  { echo > /dev/stderr;  set -x; }
      "$VBHL"  --startvm  "$VMNAME" )
  fi

  wait_for_other_virtualbox_management_to_finish  install
  #---------------------------------------------------------------------------
  info_message "start '$VMNAME' :  controlvm (${XWCPULOAD})"
  #---------------------------------------------------------------------------
  ( [ "$VERBOSE" ]  &&  set -x
    "$VBMGT"  controlvm  "$VMNAME"  cpuexecutioncap  "$XWCPULOAD" )
fi

#
# stop VM
#
[ "$STOP" = "TRUE" ]  &&  stop

#
# uninstall VM
#
[ "$UNINSTALL" = "TRUE" ]  &&  clean

exit 0
###########################################################
#     EOF        EOF     EOF        EOF     EOF       EOF #
###########################################################
